Installation
==========

- Install docker
- Run:
    - `docker-compose build`
    - `docker-compose up -d`
    - `docker-compose exec php php artisan key:generate`
    - `docker-compose exec php composer install`
    - `docker-compose exec php php artisan migrate --force --seed`
- Main app - http://localhost
- PHPMyAdmin - http://localhost:8081
- DB/PHPMyAdmin доступы цепляются автоматом из `.env`
- Для апдейта пакетов команда
    - `docker-compose exec php composer update`

Git-flow
==========

#### Пошаговая инструкция работы по Git-flow

Стоит уточнить, что обычно ветка разработки называется либо "**dev**" либо "**develop**", но у нас по некоторым 
историческим причинам эта ветка зовется "**stage**"

Шаг 0 - ветка **stage** создается из **master**, происходит это 1 раз в начале

Шаг 1 - вы начали делать задачу, у нее какой-то там идентификатор (обычно это несколько символов после последнего
слеша в адресе задачи), и вы создаете из ветки **stage** новую "feature-ветку" которая начинается с этого идентификатора,
делается это для упрощения поиска ветки в дальнейшем

Шаг 2 - задача реализована, или по кайней мере вы так думаете, ее нужно тестировать, делать это нужно обязательно 
до того как мержить вашу "feature-ветку" в **stage**, иначе если у вас там имеется баг, или какойто еще косяк то он 
неизбежно попадет в "feature-ветку" к другому разработчику, а другой разработчик не будет знать это это сломал не он
и тоже будет его исправлять, в результате будут конфликты которые решать будет проблематично.

Шаг 2.1 - если тестировщик или owner нашли баг или какое-то несоответствие бизнес потребностям - дорабатываем и 
повторяем предыдущий шаг

Шаг 2.2 - если все ок то мержим "feature-ветку" в **stage**, желательно это делать не у себя на локальной машине а на 
репозитории, создается Pull-request, где перед мержем можно посмотреть изменения, сделать Code review и т.д. 
Если в репозитории при создании Pull-request видим сообщение "Can’t automatically merge" то на локале делаем Update ветки
**stage** после чего мержим **stage** в нашу "feature-ветку" и решаем возникшие конфликты. Это происходит изза того что
ветка **stage** была кем-то изменена после того как вы создали из нее свою "feature-ветку"

Шаг 3 - ветка **stage** успешно наполняется новым функционалом и пришло время залить все свежее на Продакшн.
для этого из **stage** ветки создается "release-ветка", как ее именовать вопрос открытый, обычно используется версионность,
ну или просто номера по-порядку по типу **release-1**, **release-2** и т.д.

Шаг 4 - после создания "release-ветки" разработчики спокойно могут дальше работать от **stage** эти изменения в релиз 
уже не попадут. А тем временем "release-ветка" тестируется и все задачи в ней, обычно для этого существуют тесты, 
но у нас это пока только перспектива, так что, проверяем руками.

Шаг 4.1 - Если в релиз "release-ветке" найдены косяки то исправляются прямо в ней, до того пока все не будет ОК.

Шаг 4.2 - Когда все ОК, делается уже мерж "release-ветки" в **master**, если "release-ветка" правилась то 
мержим ее и в **stage**

Шаг 5 - Если вдруг, каким-то образом, баг обнаружили уже на Продакшене, то прямо из **master** создается "hotfix-ветка"
в которой делается исправление и мержится как обратно в **master** так и в **stage**

Вот как то так, вкратце, выглядит работа по Git-flow, выглядит сложно но такой подход гарантирует стабильность.

Есть консольная библиотека автоматизирующая процесс создания и перемещения веток, но лучше без нее
вот описание, а также наглядная картинка перемещения веток https://danielkummer.github.io/git-flow-cheatsheet/index.ru_RU.html

